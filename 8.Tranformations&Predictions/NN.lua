--This Code Create the Testing and training tensors for runing a Neural Network model 

require 'nn'
require 'optim'
require 'torch'
require 'itorch'
require 'image'
require 'gnuplot'
require 'csvigo'


trainSize = 8942
testSize = 2980
validationSize = 2980
features = 31

-- cutorch.setDevice(2)
local batch_size = 2


local path = '/path/'
trainDataFile= path .. features .. '_training.csv'
trainLabelFile= path .. features .. '_trainLabel.csv'
testDataFile= path .. features .. '_test.csv'
testLabelFile= path .. features .. '_testLabel.csv'


function file_exists(file)
   local  tf = io.open(file,"r")
   if tf ~= nil then
	  io.close(tf)
	  return true
   else
	  print(string.format("File %s doesn't exist",file))
	  os.exit()
   end
end

file_exists(trainDataFile)
file_exists(trainLabelFile)
file_exists(testDataFile)
file_exists(testLabelFile)
file_exists(validationDataFile)
file_exists(validationLabelFile)

torch.manualSeed(1)
torch.setdefaulttensortype('torch.DoubleTensor')
-- train data load and reduction
classes={'M','G'}
-- print(classes)
trainDataset ={}
testDataset={}
validationDataset={}

-----------------------------

function ReadFileCreateTensor(file, path, features, name)
  
  function string:split(sep)
    local sep, fields = sep, {}
    local pattern = string.format("([^%s]+)", sep)
    self:gsub(pattern, function(substr) fields[#fields + 1] = substr end)
    return fields
  end


  local filePath = file
  -- Count number of rows and columns in file
  local i = 0
  for line in io.lines(filePath) do
    if i == 0 then
      COLS = #line:split(',')
    end
    i = i + 1
  end
  local ROWS = i
  -- Read data from CSV to tensor
  local csvFile = io.open(filePath, 'r')
  local data = torch.Tensor(ROWS, COLS)
  local i = 0
  for line in csvFile:lines('*l') do
    i = i + 1
    local l = line:split(',')
    for key, val in ipairs(l) do
      data[i][key] = val
    end
  end
  csvFile:close()
  -- Serialize tensor
  local outputFilePath = path .. features .. name .. '.th7'
  torch.save(outputFilePath, data)
  return data
end
------------------------------

trainDataFileTENSOR= ReadFileCreateTensor(trainDataFile, path, features, 'train')
trainLabelFileTENSOR=ReadFileCreateTensor(trainLabelFile, path, features, 'trainlabel')
testDataFileTENSOR= ReadFileCreateTensor(testDataFile, path, features, 'test')
testLabelFileTENSOR= ReadFileCreateTensor(testLabelFile, path, features, 'testlabel')


function createDataset(datafile, labelfile) 
  
  local trainTensor = datafile
  
  local labelTensor = labelfile
  
  local dataset = {
	  ["data"] = trainTensor,
	  ["labels"] = labelTensor
  }
  setmetatable(dataset,
				{
				   __index=function(t,i)
					  return {torch.Tensor(t.data[i]), torch.Tensor({t.labels[i][1]})}
				end }
  )
  function dataset:size()
	  return self.data:size(1)
  end
  return dataset
end


trainDataset = createDataset(trainDataFileTENSOR, trainLabelFileTENSOR)
trainDataset.data = trainDataset.data:double() 

testDataset = createDataset(testDataFileTENSOR, testLabelFileTENSOR)
testDataset.dat = testDataset.data:double()   

----------------------------------------------------------------------

mlp = torch.load(path .. 'ModelNN.net')

criterion = nn.ClassNLLCriterion()
trainer = nn.StochasticGradient(mlp,criterion)
trainer.learningRate = 0.005
trainer.maxIteration=2000

time = os.date("*t")
print(time.hour .. ":" .. time.min .. ":" .. time.sec)

local x = os.clock()

trainer:train(trainDataset)

-- Low level training Of a Neural Network
function gradUpdate(mlp, x, y, criterion, learningRate)
   print('Aqui2')
   local pred = mlp:forward(x)
   local err= criterion:forward(pred,y)
   local gradCriterion = criterion:backward(pred,y)
   mlp:zeroGradParameters()
   mlp:backward(x,gradCriterion)
   mlp:updateParameters(learningRate)
end

local modelToSave = path .. features .. 'ModelNN.net'
torch.save(modelToSave, mlp)


print(string.format("elapsed time: %.2f\n", os.clock() - x))

time = os.date("*t")
print(time.hour .. ":" .. time.min .. ":" .. time.sec)
